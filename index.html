<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Merger tool (JS, HTML, CSS)</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/@primer/css@20.8.3/dist/primer.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.30.1/min/vs/loader.min.js"></script>
    <style>
      * {
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        text-rendering: optimizeLegibility;
        box-sizing: border-box;
      }

      .codicon-diff-insert:before,
      .codicon-diff-remove:before,
      .monaco-editor .margin-view-overlays .cldr {
        display: none !important;
      }

      body,
      html {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #f6f8fa;
        font-size: 14px;
      }

      .container-full {
        height: 100vh;
        width: 100vw;
        display: flex;
        flex-direction: column;
      }

      .Box {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        margin: 0;
        height: 100%;
      }

      .Box-header-custom {
        height: 2.5rem;
        padding: 0 0.75rem !important;
        display: flex;
        align-items: center;
        flex: 0 0 auto;
      }

      .Box-body-custom {
        flex: 1;
        display: flex;
        padding: 0.5rem !important;
        height: calc(100% - 2.5rem) !important;
        overflow: hidden;
      }

      .Box-title {
        font-size: 0.8rem;
        font-weight: 700;
        margin: 0;
      }

      .editor-column {
        display: flex;
        flex-direction: column;
        width: 50%;
        height: 100%;
        overflow: hidden;
        padding: 0.25rem;
      }

      .editor-container {
        border: 1px solid #e1e4e8;
        border-radius: 4px;
        overflow: hidden;
      }

      #finalVersionCode,
      #updatedCode {
        flex-grow: 1 !important;
      }

      :not(.comments-layout) #updatedCode {
        flex-grow: 1 !important;
        min-height: 400px !important;
      }

      .comments-layout #originalCode {
        flex-grow: 1 !important;
      }

      .button-group {
        margin-top: 0.4rem;
      }

      .notification {
        font-family: monospace !important;
        font-size: 0.7rem !important;
        position: fixed;
        top: 3.5rem;
        right: 1.25rem;
        padding: 0.2rem 0.4rem;
        border-radius: 3px;
        color: white;
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
      }

      .notification.show {
        opacity: 1;
      }

      .notification.success {
        background-color: #28a745;
      }

      .notification.error {
        background-color: #dc3545;
      }

      #backdrop {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 999;
        display: none;
      }

      #diffEditorContainer {
        position: absolute;
        top: 10%;
        left: 10%;
        width: 80%;
        height: 80%;
        background-color: white;
        border: 1px solid #e1e4e8;
        z-index: 1000;
        display: none;
        overflow: hidden;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
      }

      .monaco-diff-editor .diffViewport {
        background: none !important;
      }

      .comments-layout .updated-code-section {
        display: none;
      }

      .comments-layout #originalCode {
        height: calc(100% - 4.5rem) !important;
      }

      :not(.comments-layout) #originalCode,
      :not(.comments-layout) #updatedCode {
        height: calc(50% - 2.25rem) !important;
      }

      .mono {
        color: #ff00ff;
        font-weight: 400;
        font-size: 0.7rem;
        font-family: monospace !important;
      }

      .lpad {
        margin-left: 0.25rem !important;
      }

      .btn {
        font-size: 0.8rem;
        padding: 0.2rem 0.4rem;
      }

      .Box-title svg {
        margin: 0.1rem 0.2rem;
      }

      .svgButton {
        padding: 0.3rem;
        background-color: #1e1e1e;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 1px 0 rgba(27, 31, 35, 0.04);
        border-radius: 4px;
        border: 1px solid rgba(27, 31, 35, 0.15);
        margin-right: 0.5rem;
      }

      .svgButton svg {
        fill: #d6ff0b;
      }

      .monaco-editor {
        font-size: 11px !important;
      }

      .form-group {
        display: flex;
        align-items: center;
        margin-bottom: 1rem;
      }

      .editor-label {
        white-space: nowrap;
        margin-right: 0.5rem;
      }

      #languageSelect {
        width: auto;
        margin-right: 1.5rem !important;
      }

      .description-container {
        flex-grow: 1;
        line-height: 12px !important;
        margin-right: 30px !important;
      }

      .description {
        font-size: 0.75rem;
        color: #6c757d;
      }

      @media (max-height: 600px) {
        body,
        html {
          font-size: 12px;
        }

        .Box-header-custom {
          height: 2.25rem;
        }

        .Box-body-custom {
          height: calc(100% - 2.25rem) !important;
        }

        .button-group {
          margin-top: 0.2rem;
        }

        .btn {
          font-size: 0.7rem;
          padding: 0.15rem 0.4rem;
        }

        .monaco-editor {
          font-size: 10px !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="container-full">
      <div class="Box">
        <div class="Box-header Box-header-custom">
          <h3 class="Box-title">
            <span class="svgButton"
              ><svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 16 16"
                width="10"
                height="10"
              >
                <path
                  d="M4.72.22a.75.75 0 0 1 1.06 0l1 .999a3.488 3.488 0 0 1 2.441 0l.999-1a.748.748 0 0 1 1.265.332.75.75 0 0 1-.205.729l-.775.776c.616.63.995 1.493.995 2.444v.327c0 .1-.009.197-.025.292.408.14.764.392 1.029.722l1.968-.787a.75.75 0 0 1 .556 1.392L13 7.258V9h2.25a.75.75 0 0 1 0 1.5H13v.5c0 .409-.049.806-.141 1.186l2.17.868a.75.75 0 0 1-.557 1.392l-2.184-.873A4.997 4.997 0 0 1 8 16a4.997 4.997 0 0 1-4.288-2.427l-2.183.873a.75.75 0 0 1-.558-1.392l2.17-.868A5.036 5.036 0 0 1 3 11v-.5H.75a.75.75 0 0 1 0-1.5H3V7.258L.971 6.446a.75.75 0 0 1 .558-1.392l1.967.787c.265-.33.62-.583 1.03-.722a1.677 1.677 0 0 1-.026-.292V4.5c0-.951.38-1.814.995-2.444L4.72 1.28a.75.75 0 0 1 0-1.06Zm.53 6.28a.75.75 0 0 0-.75.75V11a3.5 3.5 0 1 0 7 0V7.25a.75.75 0 0 0-.75-.75ZM6.173 5h3.654A.172.172 0 0 0 10 4.827V4.5a2 2 0 1 0-4 0v.327c0 .096.077.173.173.173Z"
                ></path></svg></span> CODE REVIEW TOOL</h3>
          <div class="ml-auto">
            <button
              id="importBtn"
              class="btn btn-sm"
              data-tooltip="Import file (Ctrl+O)"
            >
              Import
            </button>
            <button
              id="exportBtn"
              class="btn btn-sm"
              data-tooltip="Export merged code (Ctrl+S)"
            >
              Export
            </button>
          </div>
        </div>
        <div class="Box-body Box-body-custom">
          <div class="editor-column pr-2">
            <div class="form-group d-flex align-items-center">
              <label for="languageSelect" class="editor-label mr-2"
                >Feature set:</label
              >
              <select id="languageSelect" class="form-select mr-2">
                <option value="javascript">JavaScript</option>
                <option value="css">CSS</option>
                <option value="html">HTML</option>
                <option value="comments">Comments</option>
              </select>
              <div class="description-container">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="10" height="10"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>
                <span id="defaultDescription" class="description text-muted">
                  The merge functionality takes two versions of the same code and outputs a final version using the best parts from each.</span>
                <span
                  id="commentsDescription"
                  class="description text-muted"
                  style="display: none"
                  >Removes existing comments and adds JSDoc comments above global imports, functions, and variable declarations.</span
                >
              </div>
            </div>
            <div id="codeTypeComments" class="editor-label">
              Starting version: <span class="mono"> javascript</span>
            </div>
            <div id="codeTypeOthers" class="editor-label">Base version:</div>
            <div id="originalCode" class="editor-container"></div>
            <div class="updated-code-section">
              <div class="editor-label mt-2">New version:</div>
              <div id="updatedCode" class="editor-container"></div>
            </div>
            <div class="button-group">
              <button
                id="mergeBtn"
                class="btn btn-primary btn-sm"
                data-tooltip="Merge changes"
              >
                Merge
              </button>
              <button
                id="analyzeBtn"
                class="btn btn-primary btn-sm"
                style="display: none"
                data-tooltip="Analyze code"
              >
                Generate JSON
              </button>
            </div>
          </div>
          <div class="editor-column pl-2 pt-4">
            <div id="finalHeader" class="editor-label">Final output:</div>
            <div id="finalVersionCode" class="editor-container"></div>
            <div class="button-group">
              <button
                id="copyBtn"
                class="btn btn-sm"
                data-tooltip="Copy merged code"
              >
                Copy
              </button>
              <button
                id="showDiffBtn"
                class="btn btn-sm"
                data-tooltip="Show Differences"
              >
                View differences
              </button>
              <button
                id="insertCommentsBtn"
                class="btn btn-primary btn-sm"
                style="display: none"
                data-tooltip="Insert Comments"
              >
                Insert JSDocs
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="backdrop"></div>
    <div id="diffEditorContainer"></div>
    <script src="https://unpkg.com/acorn@8.7.1/dist/acorn.js"></script>
    <script src="https://unpkg.com/acorn-walk@8.2.0/dist/walk.js"></script>
    <script src="https://unpkg.com/acorn@8.7.1/dist/acorn.js"></script>
    <script src="https://unpkg.com/acorn-walk@8.2.0/dist/walk.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        require.config({
          paths: {
            vs: "https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.30.1/min/vs",
          },
        });

        require(["vs/editor/editor.main"], function () {
          let originalEditor,
            updatedEditor,
            finalVersionEditor,
            diffEditor,
            backdrop;

          const languageSelect = document.getElementById("languageSelect");
          let isShowingDiff = false;
          const defaultDescription =
            document.getElementById("defaultDescription");
          const commentsDescription = document.getElementById(
            "commentsDescription"
          );

          function updateDescription() {
            if (languageSelect.value === "comments") {
              defaultDescription.style.display = "none";
              commentsDescription.style.display = "inline";
            } else {
              defaultDescription.style.display = "inline";
              commentsDescription.style.display = "none";
            }
          }

          languageSelect.addEventListener("change", updateDescription);
          updateDescription();

          function createEditor(elementId, language, readOnly = false) {
            return monaco.editor.create(document.getElementById(elementId), {
              value: "",
              language: language,
              theme: "vs-light",
              minimap: { enabled: false },
              scrollBeyondLastLine: false,
              lineNumbers: "on",
              renderWhitespace: "all",
              wordWrap: "on",
              autoClosingBrackets: "always",
              autoIndent: "full",
              formatOnPaste: true,
              formatOnType: true,
              automaticLayout: true,
              readOnly: readOnly,
            });
          }

          function initializeEditors(language) {
            if (originalEditor) originalEditor.dispose();
            if (updatedEditor) updatedEditor.dispose();
            if (finalVersionEditor) finalVersionEditor.dispose();

            originalEditor = createEditor("originalCode", language);
            updatedEditor = createEditor("updatedCode", language);
            finalVersionEditor = createEditor(
              "finalVersionCode",
              language === "comments" ? "json" : language,
              true
            );

            backdrop = document.getElementById("backdrop");
            if (backdrop) {
              backdrop.addEventListener("click", hideDiff);
            }

            document.addEventListener("keydown", function (event) {
              if (event.key === "Escape" && isShowingDiff) {
                hideDiff();
              }
            });

            updateLayout(language);
          }

          function updateLayout(language) {
            const container = document.querySelector(".container-full");
            const originalCodeElement = document.getElementById("originalCode");
            const updatedCodeElement = document.getElementById("updatedCode");
            const headerHeight =
              document.querySelector(".Box-header-custom")?.offsetHeight || 0;
            const codeTypeComments =
              document.getElementById("codeTypeComments");
            const codeTypeOthers = document.getElementById("codeTypeOthers");
            const bottomPadding = 80;

            const insertCommentsBtn =
              document.getElementById("insertCommentsBtn");
            const removeAndInsertBtn = document.getElementById(
              "removeAndInsertCommentsBtn"
            );
            const analyzeBtn = document.getElementById("analyzeBtn");
            const mergeBtn = document.getElementById("mergeBtn");
            const showDiffBtn = document.getElementById("showDiffBtn");

            if (language === "comments") {
              container?.classList.add("comments-layout");
              if (originalCodeElement) {
                originalCodeElement.style.height = `calc(100vh - ${headerHeight}px - ${bottomPadding}px)`;
                originalCodeElement.style.maxHeight = "none";
                originalCodeElement.style.minHeight = "0";
              }
              if (updatedCodeElement) updatedCodeElement.style.display = "none";
              if (mergeBtn) mergeBtn.style.display = "none";
              if (analyzeBtn) analyzeBtn.style.display = "inline-block";
              if (insertCommentsBtn)
                insertCommentsBtn.style.display = "inline-block";
              if (removeAndInsertBtn)
                removeAndInsertBtn.style.display = "inline-block";
              if (showDiffBtn) showDiffBtn.style.display = "none";
              if (codeTypeComments) codeTypeComments.style.display = "block";
              if (codeTypeOthers) codeTypeOthers.style.display = "none";
              if (finalVersionEditor)
                monaco.editor.setModelLanguage(
                  finalVersionEditor.getModel(),
                  "json"
                );
            } else {
              container?.classList.remove("comments-layout");
              const editorHeight = `calc((100vh - ${headerHeight}px - ${bottomPadding}px) / 2 - 20px)`;
              if (originalCodeElement) {
                originalCodeElement.style.height = editorHeight;
                originalCodeElement.style.maxHeight = "none";
                originalCodeElement.style.minHeight = "200px";
              }
              if (updatedCodeElement) {
                updatedCodeElement.style.height = editorHeight;
                updatedCodeElement.style.maxHeight = "none";
                updatedCodeElement.style.minHeight = "200px";
                updatedCodeElement.style.display = "block";
              }
              if (mergeBtn) mergeBtn.style.display = "inline-block";
              if (analyzeBtn) analyzeBtn.style.display = "none";
              if (insertCommentsBtn) insertCommentsBtn.style.display = "none";
              if (removeAndInsertBtn) removeAndInsertBtn.style.display = "none";
              if (showDiffBtn) showDiffBtn.style.display = "inline-block";
              if (codeTypeComments) codeTypeComments.style.display = "none";
              if (codeTypeOthers) codeTypeOthers.style.display = "block";
              if (finalVersionEditor)
                monaco.editor.setModelLanguage(
                  finalVersionEditor.getModel(),
                  language
                );
            }

            if (originalEditor) originalEditor.layout();
            if (updatedEditor) updatedEditor.layout();
            if (finalVersionEditor) finalVersionEditor.layout();
          }

          languageSelect?.addEventListener("change", function () {
            initializeEditors(this.value);
          });
          initializeEditors("javascript");

          window.addEventListener("resize", function () {
            updateLayout(languageSelect?.value);
          });

          document
            .getElementById("showDiffBtn")
            ?.addEventListener("click", function () {
              const originalCode = originalEditor?.getValue();
              const finalCode = finalVersionEditor?.getValue();

              if (!originalCode || !finalCode) {
                showNotification(
                  "Both the original and final versions of the code must be present to show differences.",
                  "error"
                );
                return;
              }

              if (isShowingDiff) {
                hideDiff();
              } else {
                showDiff(originalCode, finalCode, languageSelect?.value);
              }
            });

          function showDiff(original, modified, language) {
            if (diffEditor) {
              diffEditor.dispose();
              diffEditor = null;
            }

            const diffEditorContainer = document.getElementById(
              "diffEditorContainer"
            );
            if (!diffEditorContainer) return;

            diffEditor = monaco.editor.createDiffEditor(diffEditorContainer, {
              enableSplitViewResizing: false,
              renderSideBySide: true,
              readOnly: true,
              automaticLayout: true,
            });

            const originalModel = monaco.editor.createModel(original, language);
            const modifiedModel = monaco.editor.createModel(modified, language);

            diffEditor.setModel({
              original: originalModel,
              modified: modifiedModel,
            });

            diffEditorContainer.style.display = "block";
            if (backdrop) backdrop.style.display = "block";
            isShowingDiff = true;
          }

          function hideDiff() {
            if (diffEditor) {
              diffEditor.dispose();
              diffEditor = null;
            }
            const diffEditorContainer = document.getElementById(
              "diffEditorContainer"
            );
            if (diffEditorContainer) diffEditorContainer.style.display = "none";
            if (backdrop) backdrop.style.display = "none";
            isShowingDiff = false;
          }

          async function mergeCodeWithOpenAI(original, updated) {
            let typeOfCode = languageSelect?.value;
            console.log(typeOfCode);
            const language = languageSelect?.value;
            const apiKey =
              "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";
            const apiUrl = "https://api.openai.com/v1/chat/completions";

            const systemPrompt = `You are an expert code merger. Given two versions of ${language} code, merge them intelligently, keeping the best parts of both and resolving any conflicts. Here are the two versions:
  
                  Type of code:
                  ${typeOfCode}
                          
                  Original Code:
                  ${original}
                  
                  Updated Code:
                  ${updated}
  
                  Please only provide the code without any markdown code block quotes at the start or end. Just include the raw final code and nothing else. No other explanations or anything. And always include the full length of the code no matter how long it is. Don't ever change code so that you can squeeze it into a single response. Instead, include as much of the full length code as you can but make sure to stop at a good part in the code so that you can easily use code comments to list the the remaining parts of the code that need to be included still - and fit this entirely in a single message. ALWAYS FOLLOW THESE RULES EXACTLY.`;

            try {
              const response = await fetch(apiUrl, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${apiKey}`,
                },
                body: JSON.stringify({
                  model: "gpt-4o-mini",
                  messages: [
                    {
                      role: "system",
                      content: systemPrompt,
                    },
                    {
                      role: "user",
                      content: "Please merge the code versions provided above.",
                    },
                  ],
                  temperature: 1,
                  max_tokens: 16383,
                }),
              });

              const data = await response.json();
              if (
                data.choices &&
                data.choices.length > 0 &&
                data.choices[0].message
              ) {
                return data.choices[0].message.content;
              } else {
                console.error("Unexpected API response:", data);
                throw new Error(
                  "Unexpected response structure from OpenAI API"
                );
              }
            } catch (error) {
              console.error("Error calling OpenAI API:", error);
              throw error;
            }
          }

          function analyzeJavaScriptStructure(code) {
            try {
              if (typeof acorn === "undefined") {
                throw new Error(
                  "Acorn is not defined. Falling back to basic analysis."
                );
              }
              const ast = acorn.parse(code, {
                ecmaVersion: 2020,
                sourceType: "module",
                locations: true,
                allowHashBang: true,
                allowReserved: true,
                allowReturnOutsideFunction: true,
                allowImportExportEverywhere: true,
              });

              let sections = [];
              let importSection = null;

              function addSection(type, start, end, name = "") {
                while (end > start && code.split("\n")[end - 1].trim() === "") {
                  end--;
                }
                const sectionCode = code
                  .split("\n")
                  .slice(start - 1, end)
                  .join("\n");
                const description = generateMeaningfulDescription({
                  type,
                  code: sectionCode,
                });
                sections.push({
                  type: type,
                  lineStart: start,
                  lineEnd: end,
                  name: name,
                  code: sectionCode,
                  desc: description,
                });
              }

              acorn.walk.simple(ast, {
                ImportDeclaration(node) {
                  if (!importSection) {
                    importSection = {
                      type: "Imports/Requires",
                      lineStart: node.loc.start.line,
                      lineEnd: node.loc.end.line,
                    };
                  } else {
                    importSection.lineEnd = node.loc.end.line;
                  }
                },
                VariableDeclaration(node) {
                  if (node.parent.type === "Program") {
                    addSection(
                      "Variable Declaration",
                      node.loc.start.line,
                      node.loc.end.line
                    );
                  }
                },
                FunctionDeclaration(node) {
                  if (node.parent.type === "Program") {
                    addSection(
                      "Function",
                      node.loc.start.line,
                      node.loc.end.line,
                      node.id.name
                    );
                  }
                },
                ClassDeclaration(node) {
                  if (node.parent.type === "Program") {
                    addSection(
                      "Class",
                      node.loc.start.line,
                      node.loc.end.line,
                      node.id.name
                    );
                  }
                },
                ExpressionStatement(node) {
                  if (
                    node.parent.type === "Program" &&
                    node.expression.type === "AssignmentExpression" &&
                    node.expression.right.type === "FunctionExpression"
                  ) {
                    addSection(
                      "Function Assignment",
                      node.loc.start.line,
                      node.loc.end.line
                    );
                  }
                },
              });

              if (importSection) {
                const importCode = code
                  .split("\n")
                  .slice(importSection.lineStart - 1, importSection.lineEnd)
                  .join("\n");
                const importDescription = generateMeaningfulDescription({
                  type: "Imports/Requires",
                  code: importCode,
                });
                importSection.desc = importDescription;
                importSection.code = importCode;
                sections.unshift(importSection);
              }

              return sections;
            } catch (error) {
              console.error("Error parsing code:", error);
              return fallbackAnalysis(code);
            }
          }

          function fallbackAnalysis(code) {
            const lines = code.split("\n");
            const sections = [];
            let currentSection = null;

            const startNewSection = (type, lineNum) => {
              if (currentSection) {
                while (
                  currentSection.lineEnd > currentSection.lineStart &&
                  lines[currentSection.lineEnd - 1].trim() === ""
                ) {
                  currentSection.lineEnd--;
                }
                currentSection.code = lines
                  .slice(currentSection.lineStart - 1, currentSection.lineEnd)
                  .join("\n");
                currentSection.desc =
                  generateMeaningfulDescription(currentSection);
                sections.push(currentSection);
              }
              currentSection = { type, lineStart: lineNum, lineEnd: lineNum };
            };

            lines.forEach((line, index) => {
              const lineNum = index + 1;
              const trimmedLine = line.trim();

              if (
                trimmedLine.startsWith("import ") ||
                trimmedLine.startsWith("require(")
              ) {
                if (
                  !currentSection ||
                  currentSection.type !== "Imports/Requires"
                ) {
                  startNewSection("Imports/Requires", lineNum);
                }
              } else if (
                trimmedLine.startsWith("function ") ||
                trimmedLine.match(/^(const|let|var)\s+\w+\s*=\s*function/)
              ) {
                startNewSection("Function", lineNum);
              } else if (trimmedLine.startsWith("class ")) {
                startNewSection("Class", lineNum);
              } else if (
                trimmedLine.startsWith("const ") ||
                trimmedLine.startsWith("let ") ||
                trimmedLine.startsWith("var ")
              ) {
                startNewSection("Variable Declaration", lineNum);
              }

              if (currentSection) {
                currentSection.lineEnd = lineNum;
              }
            });

            if (currentSection) {
              while (
                currentSection.lineEnd > currentSection.lineStart &&
                lines[currentSection.lineEnd - 1].trim() === ""
              ) {
                currentSection.lineEnd--;
              }
              currentSection.code = lines
                .slice(currentSection.lineStart - 1, currentSection.lineEnd)
                .join("\n");
              currentSection.desc =
                generateMeaningfulDescription(currentSection);
              sections.push(currentSection);
            }

            return sections;
          }

          async function analyzeCodeWithOpenAI(code) {
            let typeOfCode = languageSelect?.value;
            console.log(typeOfCode);
            const apiKey =
              "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";
            const apiUrl = "https://api.openai.com/v1/chat/completions";

            const codeStructure = analyzeJavaScriptStructure(code);

            const systemPrompt = `You are an AI assistant tasked with providing detailed descriptions for sections of JavaScript code. You will receive a JSON structure representing different sections of the code, including their types and line numbers. This structure focuses on globally scoped elements and functions. Your task is to provide a brief, informative description for each section. Here's the structure of the code:
      
              Make sure the json is returned without any markdown backticks before or after. Only reply with properly formatted json, starting with a [ and ending with a ].
      
              
              Please follow this format, ensuring that each section has a 'desc' field. Remember, these sections represent globally scoped elements and functions, so provide context accordingly.`;

            try {
              const response = await fetch(apiUrl, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${apiKey}`,
                },
                body: JSON.stringify({
                  model: "gpt-4o-mini",
                  messages: [
                    {
                      role: "system",
                      content: systemPrompt,
                    },
                    {
                      role: "user",
                      content: `
                  Provide descriptions for the code sections. Examples:
                  [
                      {
                          "type": "Function",
                          "lineStart": 1,
                          "lineEnd": 7,
                          "name": "handleTouchStart",
                          "desc": "Handles the initial touch event by preventing default behavior and capturing the starting touch coordinates to begin a pan operation."
                      },
                      {
                          "type": "Function",
                          "lineStart": 8,
                          "lineEnd": 14,
                          "name": "handleTouchMove",
                          "desc": "Handles the touch move event by preventing default behavior and updating the pan position using the current touch coordinates, allowing for continuous panning."
                      }
                  ]`,
                    },
                  ],
                  temperature: 1,
                  max_tokens: 16383,
                }),
              });

              const data = await response.json();
              if (
                data.choices &&
                data.choices.length > 0 &&
                data.choices[0].message
              ) {
                return data.choices[0].message.content;
              } else {
                console.error("Unexpected API response:", data);
                throw new Error(
                  "Unexpected response structure from OpenAI API"
                );
              }
            } catch (error) {
              console.error("Error calling OpenAI API:", error);
              throw error;
            }
          }

          function showLoading(isLoading) {
            const mergeBtn = document.getElementById("mergeBtn");
            const analyzeBtn = document.getElementById("analyzeBtn");
            const insertCommentsBtn =
              document.getElementById("insertCommentsBtn");
            const removeAndInsertBtn = document.getElementById(
              "removeAndInsertCommentsBtn"
            );
            if (mergeBtn) mergeBtn.disabled = isLoading;
            if (analyzeBtn) analyzeBtn.disabled = isLoading;
            if (insertCommentsBtn) insertCommentsBtn.disabled = isLoading;
            if (removeAndInsertBtn) removeAndInsertBtn.disabled = isLoading;
            if (mergeBtn)
              mergeBtn.innerHTML = isLoading
                ? `<span class="spinner"></span> Process underway...`
                : "Merge Changes";
            if (analyzeBtn)
              analyzeBtn.innerHTML = isLoading
                ? `<span class="spinner"></span> Loading...`
                : "Analyze Code";
            if (insertCommentsBtn)
              insertCommentsBtn.innerHTML = isLoading
                ? `<span class="spinner"></span> Processing...`
                : "Insert Comments";
            if (removeAndInsertBtn)
              removeAndInsertBtn.innerHTML = isLoading
                ? `<span class="spinner"></span> Processing...`
                : "Comment removal + JSDocs";
          }

          function showNotification(message, type) {
            const notification = document.createElement("div");
            notification.textContent = message;
            notification.className = `notification ${type}`;
            document.body.appendChild(notification);
            setTimeout(() => {
              notification.classList.add("show");
              setTimeout(() => {
                notification.classList.remove("show");
                setTimeout(() => {
                  document.body.removeChild(notification);
                }, 300);
              }, 4000);
            }, 100);
          }

          document
            .getElementById("mergeBtn")
            ?.addEventListener("click", async function () {
              const originalCode = originalEditor?.getValue();
              const updatedCode = updatedEditor?.getValue();
              const language = languageSelect?.value;

              if (originalCode && updatedCode) {
                try {
                  showLoading(true);
                  const mergedCode = await mergeCodeWithOpenAI(
                    originalCode,
                    updatedCode
                  );
                  if (finalVersionEditor)
                    finalVersionEditor.setValue(mergedCode);
                  showNotification("Code merged successfully!", "success");
                } catch (error) {
                  showNotification(
                    "Error merging code. Please try again.",
                    "error"
                  );
                } finally {
                  showLoading(false);
                }
              } else {
                showNotification(
                  "There is currently no code to process!",
                  "error"
                );
              }
            });

          document
            .getElementById("analyzeBtn")
            ?.addEventListener("click", async function () {
              const codeToAnalyze = originalEditor?.getValue();

              if (codeToAnalyze) {
                try {
                  showLoading(true);
                  const analysisResult = await analyzeCodeWithOpenAI(
                    codeToAnalyze
                  );
                  if (finalVersionEditor)
                    finalVersionEditor.setValue(analysisResult);
                  showNotification("Code analyzed successfully!", "success");
                } catch (error) {
                  showNotification(
                    "Error analyzing code. Please try again.",
                    "error"
                  );
                } finally {
                  showLoading(false);
                }
              } else {
                showNotification("Please enter code to analyze.", "error");
              }
            });

          document
            .getElementById("copyBtn")
            ?.addEventListener("click", function () {
              const finalCode = finalVersionEditor?.getValue();
              if (!finalCode?.trim()) {
                showNotification(
                  "Error: No content to copy. Please merge or analyze code first.",
                  "error"
                );
                return;
              }
              navigator.clipboard.writeText(finalCode).then(
                function () {
                  showNotification("Copied to clipboard!", "success");
                },
                function (err) {
                  console.error("Could not copy text: ", err);
                  showNotification(
                    "Failed to copy code. Please try again.",
                    "error"
                  );
                }
              );
            });

          document
            .getElementById("importBtn")
            ?.addEventListener("click", function () {
              const fileInput = document.createElement("input");
              fileInput.type = "file";
              fileInput.accept = ".js,.css,.html";
              fileInput.onchange = function (event) {
                const file = event.target.files?.[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function (e) {
                  if (originalEditor && e.target?.result)
                    originalEditor.setValue(e.target.result.toString());
                  showNotification("File imported successfully!", "success");
                };
                reader.onerror = function () {
                  showNotification(
                    "Error importing file. Please try again.",
                    "error"
                  );
                };
                reader.readAsText(file);
              };
              fileInput.click();
            });

          document
            .getElementById("exportBtn")
            ?.addEventListener("click", function () {
              const finalCode = finalVersionEditor?.getValue();
              if (!finalCode) {
                showNotification(
                  "No content to export. Please merge or analyze code first.",
                  "error"
                );
                return;
              }
              const blob = new Blob([finalCode], { type: "text/plain" });
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download =
                "processed_code." +
                (languageSelect && languageSelect.value
                  ? languageSelect.value
                  : "txt");
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
              showNotification("File exported successfully!", "success");
            });

          function removeSingleLineComments(code) {
            return code.replace(/\/\/.*$/gm, "");
          }

          function extractParams(functionLine) {
            const match = functionLine.match(/\((.*?)\)/);
            if (match && match[1]) {
              return match[1].split(",").map((param) => param.trim());
            }
            return [];
          }

          function insertCommentsIntoCode(
            code,
            jsonInfo,
            removeComments = false
          ) {
            if (removeComments) {
              code = removeSingleLineComments(code);
            }

            const lines = code.split("\n");
            const sections = JSON.parse(jsonInfo);

            sections.sort((a, b) => a.lineStart - b.lineStart);

            let globalScopeLines = new Set();
            let bracketCount = 0;
            let inFunction = false;
            let lastGlobalLine = -1;

            lines.forEach((line, index) => {
              const trimmedLine = line.trim();

              if (
                trimmedLine.startsWith("function") ||
                trimmedLine.match(/^(async\s+)?function\s*\w*\s*\(/) ||
                trimmedLine.match(
                  /^(const|let|var)\s+\w+\s*=\s*(async\s*)?(function|\()/
                )
              ) {
                if (bracketCount === 0) {
                  globalScopeLines.add(index);
                  lastGlobalLine = index;
                }
                inFunction = true;
              }

              bracketCount += (line.match(/{/g) || []).length;
              bracketCount -= (line.match(/}/g) || []).length;

              if (bracketCount === 0) {
                inFunction = false;
              }

              if (bracketCount === 0 && !inFunction) {
                if (
                  trimmedLine.match(/^(const|let|var|import|export)\s/) ||
                  trimmedLine.startsWith("function") ||
                  trimmedLine.startsWith("class")
                ) {
                  globalScopeLines.add(index);
                  lastGlobalLine = index;
                }
              }
            });

            let insertedLines = 0;
            let commentCounter = 0;
            sections.forEach((section) => {
              const targetLine = section.lineStart - 1;
              if (globalScopeLines.has(targetLine)) {
                const comment = generateJSDocComment(commentCounter, section);
                lines.splice(
                  targetLine + insertedLines,
                  0,
                  ...comment.split("\n"),
                  ""
                );
                insertedLines += comment.split("\n").length + 1;
                commentCounter++;
              }
            });

            return lines.join("\n");
          }

          function generateJSDocComment(commentCounter, section) {
            let comment;
            if (section.type === "Function") {
              const functionName = section.name || "Anonymous";
              const params = section.code ? extractParams(section.code) : [];

              comment = `
/**
 * ${commentCounter}. ${functionName}: ${section.desc || "A function"}
 * 
 * @function
${params
  .map((param) => ` * @param {*} ${param} - Purpose of ${param}`)
  .join("\n")}
 */`.trim();
            } else if (section.type === "Variable Declaration") {
              const varName = section.name || "anonymousVar";
              const varType = section.code ? inferVarType(section.code) : "*";
              comment = `
/**
 * ${commentCounter}. ${varName}: ${section.desc || "A variable"}
 * 
 * @type {${varType}}
 */`.trim();
            } else {
              comment = `
/**
 * ${commentCounter}. ${section.type}: ${section.desc || "A code section"}
 */`.trim();
            }
            return comment;
          }

          function inferVarType(code) {
            if (code.includes("new ")) {
              const match = code.match(/new (\w+)/);
              return match ? match[1] : "object";
            } else if (code.includes("= [")) {
              return "Array";
            } else if (code.includes("= {")) {
              return "Object";
            } else if (code.includes("= true") || code.includes("= false")) {
              return "boolean";
            } else if (
              code.includes("= `") ||
              code.includes("= '") ||
              code.includes('= "')
            ) {
              return "string";
            } else if (code.match(/= \d+(\.\d+)?/)) {
              return "number";
            }
            return "*";
          }

          function generateMeaningfulDescription(section) {
            const { type, code } = section;

            if (type === "Function") {
              const functionName =
                code.match(/function\s+(\w+)/)?.[1] || "Anonymous";
              const params = extractParams(code);
              const bodyLines = code.split("\n").slice(1, -1);

              let description = `Defines the ${functionName} function`;

              if (params.length > 0) {
                description += ` that takes ${params.length} parameter${
                  params.length > 1 ? "s" : ""
                }`;
              }

              if (bodyLines.some((line) => line.includes("preventDefault()"))) {
                description += `. Prevents default event behavior`;
              }

              if (bodyLines.some((line) => line.includes(".style"))) {
                description += `. Modifies element styles`;
              }

              if (bodyLines.some((line) => line.match(/\.\w+\s*=/))) {
                description += `. Updates object properties`;
              }

              if (bodyLines.some((line) => line.includes("return"))) {
                description += `. Returns a value`;
              }

              return description + ".";
            } else if (type === "Variable Declaration") {
              const varName =
                code.match(/(const|let|var)\s+(\w+)/)?.[2] || "anonymousVar";
              const varType = inferVarType(code);

              let description = `Declares ${varName} as a ${varType}`;

              if (code.includes("=")) {
                description += " and initializes it";
                if (code.includes("document.")) {
                  description += " with a reference to a DOM element";
                } else if (code.includes("new ")) {
                  description += " as a new instance of a class";
                } else if (code.includes("function")) {
                  description += " with a function";
                }
              }

              return description + ".";
            }

            return "Defines a code section.";
          }

          const insertCommentsBtn =
            document.getElementById("insertCommentsBtn");
          if (insertCommentsBtn) {
            const removeAndInsertBtn = document.createElement("button");
            removeAndInsertBtn.id = "removeAndInsertCommentsBtn";
            removeAndInsertBtn.className = "btn btn-primary btn-sm lpad";
            removeAndInsertBtn.style.display = "none";
            removeAndInsertBtn.setAttribute(
              "data-tooltip",
              "Comment removal + JSDocs"
            );
            removeAndInsertBtn.textContent = "Comment removal + JSDocs";
            insertCommentsBtn.parentNode.insertBefore(
              removeAndInsertBtn,
              insertCommentsBtn.nextSibling
            );
          }

          document
            .getElementById("insertCommentsBtn")
            ?.addEventListener("click", function () {
              handleCommentInsertion(false);
            });

          document
            .getElementById("removeAndInsertCommentsBtn")
            ?.addEventListener("click", function () {
              handleCommentInsertion(true);
            });

          function handleCommentInsertion(removeComments) {
            const originalCode = originalEditor?.getValue();
            const jsonInfo = finalVersionEditor?.getValue();

            if (originalCode && jsonInfo) {
              try {
                showLoading(true);
                const commentedCode = insertCommentsIntoCode(
                  originalCode,
                  jsonInfo,
                  removeComments
                );
                if (finalVersionEditor)
                  finalVersionEditor.setValue(commentedCode);
                showNotification(
                  removeComments
                    ? "Comments removed and new comments inserted successfully!"
                    : "Comments inserted successfully!",
                  "success"
                );
              } catch (error) {
                console.error("Error inserting comments:", error);
                showNotification(
                  "Error inserting comments. Please check the JSON format.",
                  "error"
                );
              } finally {
                showLoading(false);
              }
            } else {
              showNotification(
                "Please ensure both original code and JSON information are present.",
                "error"
              );
            }
          }
        });
      });
    </script>
  </body>
</html>
