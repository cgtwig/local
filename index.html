<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Merger Tool (JS, HTML, CSS)</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/@primer/css@20.8.3/dist/primer.css"
    />
    <style>
        * {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
            box-sizing: border-box;
        }

        .codicon-diff-insert:before,
        .codicon-diff-remove:before,
        .monaco-editor .margin-view-overlays .cldr {
            display: none !important;
        }

        body,
        html {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f6f8fa;
            font-size: 14px;
        }

        .container-full {
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
        }

        .Box {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            margin: 0;
            height: 100%;
        }

        .Box-header-custom {
            height: 2.5rem;
            padding: 0 0.75rem !important;
            display: flex;
            align-items: center;
            flex: 0 0 auto;
        }

        .Box-body-custom {
            flex: 1;
            display: flex;
            padding: 0.5rem !important;
            height: calc(100% - 2.5rem) !important;
            overflow: hidden;
        }

        .Box-title {
            font-size: 0.8rem;
            font-weight: 700;
            margin: 0;
        }

        .editor-column {
            display: flex;
            flex-direction: column;
            width: 50%;
            height: 100%;
            overflow: hidden;
            padding: 0.25rem;
        }

        .editor-container {
            border: 1px solid #e1e4e8;
            border-radius: 4px;
            overflow: hidden;
        }

        #finalVersionCode,
        #updatedCode {
            flex-grow: 1 !important;
        }

        :not(.comments-layout) #updatedCode {
            flex-grow: 1 !important;
            min-height: 400px !important;
        }

        .comments-layout #originalCode {
            flex-grow: 1 !important;
        }

        .button-group {
            margin-top: 0.4rem;
        }

        .notification {
            font-family: monospace !important;
            font-size: 0.7rem !important;
            position: fixed;
            top: 3.5rem;
            right: 1.25rem;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            color: white;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .notification.show {
            opacity: 1;
        }

        .notification.success {
            background-color: #28a745;
        }

        .notification.error {
            background-color: #dc3545;
        }

        #backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 999;
            display: none;
        }

        #diffEditorContainer {
            position: absolute;
            top: 10%;
            left: 10%;
            width: 80%;
            height: 80%;
            background-color: white;
            border: 1px solid #e1e4e8;
            z-index: 1000;
            display: none;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }

        .monaco-diff-editor .diffViewport {
            background: none !important;
        }

        .comments-layout .updated-code-section {
            display: none;
        }

        .comments-layout #originalCode {
            height: calc(100% - 4.5rem) !important;
        }

        :not(.comments-layout) #originalCode,
        :not(.comments-layout) #updatedCode {
            height: calc(50% - 2.25rem) !important;
        }

        .mono {
            color: #ff00ff;
            font-weight: 400;
            font-size: 0.7rem;
            font-family: monospace !important;
        }

        .lpad {
            margin-left: 0.25rem !important;
        }

        .btn {
            font-size: 0.8rem;
            padding: 0.2rem 0.4rem;
        }

        .Box-title svg {
            margin: 0.1rem 0.2rem;
        }

        .svgButton {
            padding: 0.3rem;
            background-color: #1e1e1e;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 0 rgba(27, 31, 35, 0.04);
            border-radius: 4px;
            border: 1px solid rgba(27, 31, 35, 0.15);
            margin-right: 0.5rem;
        }

        .svgButton svg {
            fill: #d6ff0b;
        }

        .monaco-editor {
            font-size: 11px !important;
        }

        .form-group {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }

        .editor-label {
            white-space: nowrap;
            margin-right: 0.5rem;
        }

        #languageSelect {
            width: auto;
            margin-right: 1.5rem !important;
        }

        .description-container {
            flex-grow: 1;
            line-height: 12px !important;
            margin-right: 30px !important;
        }

        .description {
            font-size: 0.75rem;
            color: #6c757d;
        }

        @media (max-height: 600px) {

            body,
            html {
                font-size: 12px;
            }

            .Box-header-custom {
                height: 2.25rem;
            }

            .Box-body-custom {
                height: calc(100% - 2.25rem) !important;
            }

            .button-group {
                margin-top: 0.2rem;
            }

            .btn {
                font-size: 0.7rem;
                padding: 0.15rem 0.4rem;
            }

            .monaco-editor {
                font-size: 10px !important;
            }
        }

        .button-group-comments {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-top: 0.5rem;
        }

        .button-group-comments .btn {
            margin-left: 0.5rem;
        }

        .button-group-comments .checkbox-group {
            display: flex;
            align-items: center;
            margin-right: auto;
        }

        .button-group-comments .checkbox-group input {
            margin-right: 0.25rem;
        }

        .button-group {
          display: flex;
          align-items: center;
          margin-top: 0.4rem;
        }

        #progressContainer {
          flex-grow: 1;
          height: 2px;
          background-color: #e1e4e8;
          margin-left: 10px;
          position: relative;
          display: none;
        }

        #analysisProgress {
          height: 100%;
          background-color: #28a745;
          width: 0%;
          transition: width 0.3s ease-in-out;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.30.1/min/vs/loader.min.js"></script>
  </head>
  <body>
    <div class="container-full">
      <div class="Box">
        <div class="Box-header Box-header-custom">
          <h3 class="Box-title">
            <span class="svgButton">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 16 16"
                width="10"
                height="10"
              >
                <path
                  d="M4.72.22a.75.75 0 0 1 1.06 0l1 .999a3.488 3.488 0 0 1 2.441 0l.999-1a.748.748 0 0 1 1.265.332.75.75 0 0 1-.205.729l-.775.776c.616.63.995 1.493.995 2.444v.327c0 .1-.009.197-.025.292.408.14.764.392 1.029.722l1.968-.787a.75.75 0 0 1 .556 1.392L13 7.258V9h2.25a.75.75 0 0 1 0 1.5H13v.5c0 .409-.049.806-.141 1.186l2.17.868a.75.75 0 0 1-.557 1.392l-2.184-.873A4.997 4.997 0 0 1 8 16a4.997 4.997 0 0 1-4.288-2.427l-2.183.873a.75.75 0 0 1-.558-1.392l2.17-.868A5.036 5.036 0 0 1 3 11v-.5H.75a.75.75 0 0 1 0-1.5H3V7.258L.971 6.446a.75.75 0 0 1 .558-1.392l1.967.787c.265-.33.62-.583 1.03-.722a1.677 1.677 0 0 1-.026-.292V4.5c0-.951.38-1.814.995-2.444L4.72 1.28a.75.75 0 0 1 0-1.06Zm.53 6.28a.75.75 0 0 0-.75.75V11a3.5 3.5 0 1 0 7 0V7.25a.75.75 0 0 0-.75-.75ZM6.173 5h3.654A.172.172 0 0 0 10 4.827V4.5a2 2 0 1 0-4 0v.327c0 .096.077.173.173.173Z"
                ></path>
              </svg>
            </span>
            CODE REVIEW TOOL
          </h3>
          <div class="ml-auto">
            <button
              id="importBtn"
              class="btn btn-sm"
              data-tooltip="Import file (Ctrl+O)"
            >
              Import
            </button>
            <button
              id="exportBtn"
              class="btn btn-sm"
              data-tooltip="Export merged code (Ctrl+S)"
            >
              Export
            </button>
          </div>
        </div>
        <div class="Box-body Box-body-custom">
          <div class="editor-column pr-2">
            <div class="form-group d-flex align-items-center">
              <label for="languageSelect" class="editor-label mr-2"
                >Feature set:</label
              >
              <select id="languageSelect" class="form-select mr-2">
                <option value="javascript">JavaScript</option>
                <option value="css">CSS</option>
                <option value="html">HTML</option>
                <option value="comments">Comments</option>
              </select>
              <div class="description-container">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 16 16"
                  width="10"
                  height="10"
                >
                  <path
                    d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"
                  ></path>
                </svg>
                <span id="defaultDescription" class="description text-muted">
                  The merge functionality takes two versions of the same code and outputs a final version using the best parts from each.
                </span>
                <span
                  id="commentsDescription"
                  class="description text-muted"
                  style="display: none"
                  >Removes existing comments and adds JSDoc comments above global imports, functions, and variable declarations.</span
                >
              </div>
            </div>
            <div id="codeTypeComments" class="editor-label" style="display: none;">
              Starting version: <span class="mono">javascript</span>
            </div>
            <div id="codeTypeOthers" class="editor-label">Base version:</div>
            <div id="originalCode" class="editor-container"></div>
            <div class="updated-code-section">
              <div class="editor-label mt-2">New version:</div>
              <div id="updatedCode" class="editor-container"></div>
            </div>
            <div class="button-group">
              <button
                id="mergeBtn"
                class="btn btn-primary btn-sm"
                data-tooltip="Merge changes"
              >
                Merge
              </button>
              <button
                id="analyzeBtn"
                class="btn btn-primary btn-sm"
                style="display: none"
                data-tooltip="Generate JSON"
              >
                Generate JSON
              </button>
            </div>
          </div>
          <div class="editor-column pl-2 pt-4">
            <div id="finalHeader" class="editor-label">Final output:</div>
            <div id="finalVersionCode" class="editor-container"></div>
            <div class="button-group">
              <button id="copyBtn" class="btn btn-sm" data-tooltip="Copy merged code">Copy</button>
              <button id="showDiffBtn" class="btn btn-sm" data-tooltip="Show Differences">View differences</button>
              <button id="insertCommentsBtn" class="btn btn-primary btn-sm" style="display: none" data-tooltip="Keep existing comments + Insert JSDocs">
                Keep existing comments + Insert JSDocs
              </button>
              <button id="removeAndInsertCommentsBtn" class="btn btn-primary btn-sm lpad" style="display: none" data-tooltip="Remove comments + Insert JSDocs">
                Remove comments + Insert JSDocs
              </button>
              <div id="progressContainer">
                <div id="analysisProgress"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="backdrop"></div>
    <div id="diffEditorContainer"></div>
    <script src="https://unpkg.com/acorn@8.7.1/dist/acorn.js"></script>
    <script src="https://unpkg.com/acorn-walk@8.2.0/dist/walk.js"></script>
    <script>
    
  document.addEventListener("DOMContentLoaded", function () {
    require.config({
      paths: {
        vs: "https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.30.1/min/vs",
        prettier: "https://unpkg.com/prettier@2.8.8/standalone.js",
        "prettier/parser-babel": "https://unpkg.com/prettier@2.8.8/parser-babel.js",
        "prettier/parser-html": "https://unpkg.com/prettier@2.8.8/parser-html.js",
        "prettier/parser-postcss": "https://unpkg.com/prettier@2.8.8/parser-postcss.js",
      },
    });

    require([
      "vs/editor/editor.main",
      "prettier",
      "prettier/parser-babel",
      "prettier/parser-html",
      "prettier/parser-postcss"
    ], function (_, prettier, babelParser, htmlParser, postcssParser) {
      let originalEditor, updatedEditor, finalVersionEditor, diffEditor, backdrop;
      const languageSelect = document.getElementById("languageSelect");
      let isShowingDiff = false;
      const defaultDescription = document.getElementById("defaultDescription");
      const commentsDescription = document.getElementById("commentsDescription");

      function updateDescription() {
        if (languageSelect.value === "comments") {
          defaultDescription.style.display = "none";
          commentsDescription.style.display = "inline";
        } else {
          defaultDescription.style.display = "inline";
          commentsDescription.style.display = "none";
        }
      }

      languageSelect.addEventListener("change", updateDescription);
      updateDescription();

      function createEditor(elementId, language, readOnly = false) {
        return monaco.editor.create(document.getElementById(elementId), {
          value: "",
          language: language,
          theme: "vs-light",
          minimap: { enabled: false },
          scrollBeyondLastLine: false,
          lineNumbers: "on",
          renderWhitespace: "all",
          wordWrap: "on",
          autoClosingBrackets: "always",
          autoIndent: "full",
          formatOnPaste: true,
          formatOnType: true,
          automaticLayout: true,
          readOnly: readOnly,
        });
      }

      function initializeEditors(language) {
        if (originalEditor) originalEditor.dispose();
        if (updatedEditor) updatedEditor.dispose();
        if (finalVersionEditor) finalVersionEditor.dispose();

        originalEditor = createEditor("originalCode", language);
        updatedEditor = createEditor("updatedCode", language);
        finalVersionEditor = createEditor(
          "finalVersionCode",
          language === "comments" ? "json" : language,
          true
        );

        backdrop = document.getElementById("backdrop");
        if (backdrop) {
          backdrop.addEventListener("click", hideDiff);
        }

        document.addEventListener("keydown", function (event) {
          if (event.key === "Escape" && isShowingDiff) {
            hideDiff();
          }
        });

        updateLayout(language);
      }

      function updateLayout(language) {
        const container = document.querySelector(".container-full");
        const originalCodeElement = document.getElementById("originalCode");
        const updatedCodeElement = document.getElementById("updatedCode");
        const codeTypeComments = document.getElementById("codeTypeComments");
        const codeTypeOthers = document.getElementById("codeTypeOthers");
        const insertCommentsBtn = document.getElementById("insertCommentsBtn");
        const removeAndInsertBtn = document.getElementById("removeAndInsertCommentsBtn");
        const analyzeBtn = document.getElementById("analyzeBtn");
        const mergeBtn = document.getElementById("mergeBtn");
        const showDiffBtn = document.getElementById("showDiffBtn");

        if (language === "comments") {
          container?.classList.add("comments-layout");
          if (originalCodeElement) {
            originalCodeElement.style.height = `calc(100vh - 2.5rem - 80px)`;
            originalCodeElement.style.maxHeight = "none";
            originalCodeElement.style.minHeight = "0";
          }
          if (updatedCodeElement) updatedCodeElement.style.display = "none";
          if (mergeBtn) mergeBtn.style.display = "none";
          if (analyzeBtn) analyzeBtn.style.display = "inline-block";
          if (insertCommentsBtn) insertCommentsBtn.style.display = "inline-block";
          if (removeAndInsertBtn) removeAndInsertBtn.style.display = "inline-block";
          if (showDiffBtn) showDiffBtn.style.display = "none";
          if (codeTypeComments) codeTypeComments.style.display = "block";
          if (codeTypeOthers) codeTypeOthers.style.display = "none";
          if (finalVersionEditor)
            monaco.editor.setModelLanguage(finalVersionEditor.getModel(), "json");
        } else {
          container?.classList.remove("comments-layout");
          const headerHeight = 2.5 * 16;
          const bottomPadding = 80;
          const editorHeight = `calc((100vh - ${headerHeight}px - ${bottomPadding}px) / 2 - 20px)`;
          if (originalCodeElement) {
            originalCodeElement.style.height = editorHeight;
            originalCodeElement.style.maxHeight = "none";
            originalCodeElement.style.minHeight = "200px";
          }
          if (updatedCodeElement) {
            updatedCodeElement.style.height = editorHeight;
            updatedCodeElement.style.maxHeight = "none";
            updatedCodeElement.style.minHeight = "200px";
            updatedCodeElement.style.display = "block";
          }
          if (mergeBtn) mergeBtn.style.display = "inline-block";
          if (analyzeBtn) analyzeBtn.style.display = "none";
          if (insertCommentsBtn) insertCommentsBtn.style.display = "none";
          if (removeAndInsertBtn) removeAndInsertBtn.style.display = "none";
          if (showDiffBtn) showDiffBtn.style.display = "inline-block";
          if (codeTypeComments) codeTypeComments.style.display = "none";
          if (codeTypeOthers) codeTypeOthers.style.display = "block";
          if (finalVersionEditor)
            monaco.editor.setModelLanguage(finalVersionEditor.getModel(), language);
        }

        if (originalEditor) originalEditor.layout();
        if (updatedEditor) updatedEditor.layout();
        if (finalVersionEditor) finalVersionEditor.layout();
      }

      languageSelect?.addEventListener("change", function () {
        initializeEditors(this.value);
      });
      initializeEditors("javascript");

      window.addEventListener("resize", function () {
        updateLayout(languageSelect?.value);
      });

      function showDiff(original, modified, language) {
        if (diffEditor) {
          diffEditor.dispose();
          diffEditor = null;
        }

        const diffEditorContainer = document.getElementById("diffEditorContainer");
        if (!diffEditorContainer) return;

        diffEditor = monaco.editor.createDiffEditor(diffEditorContainer, {
          enableSplitViewResizing: false,
          renderSideBySide: true,
          readOnly: true,
          automaticLayout: true,
        });

        const originalModel = monaco.editor.createModel(original, language);
        const modifiedModel = monaco.editor.createModel(modified, language);

        diffEditor.setModel({
          original: originalModel,
          modified: modifiedModel,
        });

        diffEditorContainer.style.display = "block";
        if (backdrop) backdrop.style.display = "block";
        isShowingDiff = true;
      }

      function hideDiff() {
        if (diffEditor) {
          diffEditor.dispose();
          diffEditor = null;
        }
        const diffEditorContainer = document.getElementById("diffEditorContainer");
        if (diffEditorContainer) diffEditorContainer.style.display = "none";
        if (backdrop) backdrop.style.display = "none";
        isShowingDiff = false;
      }

      async function mergeCodeWithOpenAI(original, updated) {
        let typeOfCode = languageSelect?.value;
        const language = languageSelect?.value;
        const apiKey = "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";
        const apiUrl = "https://api.openai.com/v1/chat/completions";

        const systemPrompt = `You are an expert code merger. Given two versions of ${language} code, merge them intelligently, keeping the best parts of both and resolving any conflicts. Here are the two versions:
  
              Type of code:
              ${typeOfCode}
                      
              Original Code:
              ${original}
              
              Updated Code:
              ${updated}
  
              Please only provide the code without any markdown code block quotes at the start or end. Just include the raw final code and nothing else. No other explanations or anything. And always include the full length of the code no matter how long it is. Don't ever change code so that you can squeeze it into a single response. Instead, include as much of the full length code as you can but make sure to stop at a good part in the code so that you can easily use code comments to list the the remaining parts of the code that need to be included still - and fit this entirely in a single message. ALWAYS FOLLOW THESE RULES EXACTLY.`;

        const response = await fetch(apiUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify({
            model: "gpt-4o-mini",
            messages: [
              { role: "system", content: systemPrompt },
              { role: "user", content: "Please merge the code versions provided above." },
            ],
            temperature: 0.25,
            max_tokens: 16383,
          }),
        });

        const data = await response.json();
        if (data.choices && data.choices.length > 0 && data.choices[0].message) {
          return data.choices[0].message.content;
        } else {
          throw new Error("Unexpected response structure from OpenAI API");
        }
      }

      function analyzeJavaScriptStructure(code) {
        const lines = code.split('\n');
        const sections = [];
        let inFunction = false;
        let bracketCount = 0;

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          
          if (line.includes('{')) bracketCount++;
          if (line.includes('}')) bracketCount--;

          if (bracketCount === 0) inFunction = false;

          if (!inFunction && (line.startsWith('function ') || line.match(/^(const|let|var)\s+\w+\s*=\s*function/))) {
            const name = line.startsWith('function ') ? line.split(' ')[1].split('(')[0] : line.split('=')[0].trim().split(' ').pop();
            sections.push({
              type: 'Function',
              name: name,
              lineStart: i + 1,
              desc: `Defines the ${name} function`
            });
            inFunction = true;
          }
        }

        return sections;
      }

      async function analyzeCodeWithOpenAI(code) {
		  let typeOfCode = languageSelect?.value;
		  const apiKey = "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";
		  const apiUrl = "https://api.openai.com/v1/chat/completions";
		
		  const codeStructure = analyzeJavaScriptStructure(code);
		
		  const chunkSize = 1000;
		  let allDescriptions = [];
		
		  for (let i = 0; i < codeStructure.length; i += chunkSize) {
			const chunk = codeStructure.slice(i, i + chunkSize);
			const systemPrompt = `You are an AI assistant tasked with providing detailed descriptions for sections of JavaScript code. You will receive a JSON structure representing different sections of the code, including their types and line numbers. This structure focuses on globally scoped elements and functions. Your task is to provide a brief, informative description for each section. Here's the structure of the code:
		
				${JSON.stringify(chunk, null, 2)}
		
				Please provide a brief description for each section, maintaining the same JSON structure but adding a "desc" field to each object. Your response should be in valid JSON format. Focus on the purpose and functionality of each section rather than implementation details. Here's an example of the desired output format:
		
				[
					{
						"type": "Function",
						"lineStart": 1,
						"lineEnd": 7,
						"name": "handleTouchStart",
						"desc": "Handles the initial touch event by preventing default behavior and capturing the starting touch coordinates to begin a pan operation."
					},
					{
						"type": "Function",
						"lineStart": 8,
						"lineEnd": 14,
						"name": "handleTouchMove",
						"desc": "Handles the touch move event by preventing default behavior and updating the pan position using the current touch coordinates, allowing for continuous panning."
					}
				]
		
				Make sure the json is returned without any markdown backticks before or after. Only reply with properly formatted json, starting with a [ and ending with a ].
		
				Please follow this format, ensuring that each section has a 'desc' field. Remember, these sections represent globally scoped elements and functions, so provide context accordingly.`;

        try {
          const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${apiKey}`,
            },
            body: JSON.stringify({
              model: "gpt-4o-mini",
              messages: [
                { role: "system", content: systemPrompt },
                { role: "user", content: "Provide descriptions for the code sections." },
              ],
              temperature: 0.25,
              max_tokens: 16383,
            }),
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();
          if (data.choices && data.choices.length > 0 && data.choices[0].message) {
            const chunkDescriptions = JSON.parse(data.choices[0].message.content);
            allDescriptions = allDescriptions.concat(chunkDescriptions);
          } else {
            throw new Error("Unexpected response structure from OpenAI API");
          }
          const progress = Math.min(100, ((i + chunkSize) / codeStructure.length) * 100);
          updateProgressBar(progress);
          await new Promise(resolve => setTimeout(resolve, 0));
        } catch (error) {
          console.error("Error in API call:", error);
          throw error;
        }
      }

      return JSON.stringify(allDescriptions);
    }

    async function insertCommentsInChunks(code, jsonInfo, removeCommentsOption) {
      const chunkSize = 1000;
      const codeLines = code.split('\n');
      let processedCode = '';
      const sections = JSON.parse(jsonInfo);

      let commentCounter = 1;

      for (let i = 0; i < codeLines.length; i += chunkSize) {
        const chunkLines = codeLines.slice(i, i + chunkSize);
        const chunkCode = chunkLines.join('\n');
        const chunkSections = sections.filter(section => section.lineStart >= i + 1 && section.lineStart < i + chunkSize + 1);
        
        try {
          const processedChunk = insertCommentsIntoCode(chunkCode, JSON.stringify(chunkSections), removeCommentsOption, commentCounter);
          processedCode += processedChunk + '\n';
          commentCounter += chunkSections.length;
          const progress = Math.min(100, ((i + chunkSize) / codeLines.length) * 100);
          updateProgressBar(progress);
          await new Promise(resolve => setTimeout(resolve, 0));
        } catch (error) {
          console.error("Error processing chunk:", error);
          throw error;
        }
      }

      return processedCode.trim();
    }

    function updateProgressBar(progress) {
      const progressBar = document.getElementById("analysisProgress");
      const progressContainer = document.getElementById("progressContainer");
      if (progressBar && progressContainer) {
        progressContainer.style.display = "block";
        progressBar.style.width = `${progress}%`;
        progressBar.setAttribute("aria-valuenow", progress);
      }
    }

      function showLoading(isLoading) {
        const mergeBtn = document.getElementById("mergeBtn");
        const analyzeBtn = document.getElementById("analyzeBtn");
        const insertCommentsBtn = document.getElementById("insertCommentsBtn");
        const removeAndInsertBtn = document.getElementById("removeAndInsertCommentsBtn");
        const progressContainer = document.getElementById("progressContainer");
        
        if (mergeBtn) mergeBtn.disabled = isLoading;
        if (analyzeBtn) analyzeBtn.disabled = isLoading;
        if (insertCommentsBtn) insertCommentsBtn.disabled = isLoading;
        if (removeAndInsertBtn) removeAndInsertBtn.disabled = isLoading;
        
        if (isLoading) {
          if (progressContainer) {
            progressContainer.style.display = "block";
            updateProgressBar(0);
          }
        } else {
          if (progressContainer) progressContainer.style.display = "none";
        }
        
        if (mergeBtn)
          mergeBtn.innerHTML = isLoading
            ? `<span class="spinner"></span> Process underway...`
            : "Merge Changes";
        if (analyzeBtn)
          analyzeBtn.innerHTML = isLoading
            ? `<span class="spinner"></span> Analyzing...`
            : "Generate JSON";
        if (insertCommentsBtn)
          insertCommentsBtn.innerHTML = isLoading
            ? `<span class="spinner"></span> Processing...`
            : "Keep existing comments + Insert JSDocs";
        if (removeAndInsertBtn)
          removeAndInsertBtn.innerHTML = isLoading
            ? `<span class="spinner"></span> Processing...`
            : "Remove comments + Insert JSDocs";
      }

      function showNotification(message, type) {
        const notification = document.createElement("div");
        notification.textContent = message;
        notification.className = `notification ${type}`;
        document.body.appendChild(notification);
        setTimeout(() => {
          notification.classList.add("show");
          setTimeout(() => {
            notification.classList.remove("show");
            setTimeout(() => {
              document.body.removeChild(notification);
            }, 300);
          }, 4000);
        }, 100);
      }

      async function formatCode(code, parser) {
    try {
      const options = {
        parser: parser,
        plugins: [babelParser, htmlParser, postcssParser],
        singleQuote: true,
        trailingComma: "es5",
        tabWidth: 2,
      };
		
      if (parser === "json") {
        return JSON.stringify(JSON.parse(code), null, 2);
      }

      return prettier.format(code, options);
    } catch (error) {
      console.error("Error formatting code:", error);
      return code;
    }
  }

      document.getElementById("analyzeBtn")?.addEventListener("click", async function () {
        const codeToAnalyze = originalEditor?.getValue();

        if (codeToAnalyze) {
          try {
            showLoading(true);						
            const formattedCode = await formatCode(codeToAnalyze, "babel");
            originalEditor.setValue(formattedCode);

            const analysisResult = await analyzeCodeWithOpenAI(formattedCode);
            const formattedJSON = await formatCode(analysisResult, "json");
            if (finalVersionEditor) finalVersionEditor.setValue(formattedJSON);

            const insertCommentsBtn = document.getElementById("insertCommentsBtn");
            const removeAndInsertBtn = document.getElementById("removeAndInsertCommentsBtn");
            if (insertCommentsBtn) insertCommentsBtn.style.display = "inline-block";
            if (removeAndInsertBtn) removeAndInsertBtn.style.display = "inline-block";
            showNotification("Code analyzed and formatted successfully!", "success");
          } catch (error) {
            showNotification("Error analyzing code. Please try again.", "error");
          } finally {
            showLoading(false);
          }
        } else {
          showNotification("Please enter code to analyze.", "error");
        }
      });

      document.getElementById("copyBtn")?.addEventListener("click", function () {
        const finalCode = finalVersionEditor?.getValue();
        if (!finalCode?.trim()) {
          showNotification("Error: No content to copy. Please merge or analyze code first.", "error");
          return;
        }
        navigator.clipboard.writeText(finalCode).then(
          function () {
            showNotification("Copied to clipboard!", "success");
          },
          function (err) {
            showNotification("Failed to copy code. Please try again.", "error");
          }
        );
      });

      document.getElementById("importBtn")?.addEventListener("click", function () {
        const fileInput = document.createElement("input");
        fileInput.type = "file";
        fileInput.accept = ".js,.css,.html";
        fileInput.onchange = function (event) {
          const file = event.target.files?.[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = function (e) {
            if (originalEditor && e.target?.result) originalEditor.setValue(e.target.result.toString());
            showNotification("File imported successfully!", "success");
          };
          reader.onerror = function () {
            showNotification("Error importing file. Please try again.", "error");
          };
          reader.readAsText(file);
        };
        fileInput.click();
      });

      document.getElementById("exportBtn")?.addEventListener("click", function () {
        const finalCode = finalVersionEditor?.getValue();
        if (!finalCode) {
          showNotification("No content to export. Please merge or analyze code first.", "error");
          return;
        }
        const blob = new Blob([finalCode], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download =
          "processed_code." +
          (languageSelect && languageSelect.value ? languageSelect.value : "txt");
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showNotification("File exported successfully!", "success");
      });

      function removeComments(code) {
        return code.replace(/\/\*[\s\S]*?\*\/|\/\/.*$/gm, "");
      }

      function extractParams(functionLine) {
        const match = functionLine.match(/\((.*?)\)/);
        if (match && match[1]) {
          return match[1].split(",").map((param) => param.trim());
        }
        return [];
      }

      function insertCommentsIntoCode(code, jsonInfo, removeCommentsOption = true, startingCommentNumber = 1) {
        if (removeCommentsOption) {
          code = removeComments(code);
        }

        const lines = code.split("\n");
        let sections;
        try {
          sections = JSON.parse(jsonInfo);
        } catch (error) {
          throw new Error("Invalid JSON format.");
        }

        sections.sort((a, b) => a.lineStart - b.lineStart);

        let insertedLines = 0;
        let commentCounter = startingCommentNumber;
        sections.forEach((section) => {
          const targetLine = section.lineStart - 1 + insertedLines;
          if (lines[targetLine] !== undefined) {
            const comment = generateJSDocComment(commentCounter, section);
            lines.splice(targetLine, 0, ...comment.split('\n'));
            insertedLines += comment.split('\n').length;
            commentCounter++;
          }
        });

        return lines.join("\n");
      }

      function generateJSDocComment(commentCounter, section) {
        return `
        /**
        * ${commentCounter}. ${section.name}: ${section.desc}
        */`.trim();
      }

      const insertCommentsBtn = document.getElementById("insertCommentsBtn");
      if (insertCommentsBtn) {
        const removeAndInsertBtn = document.createElement("button");
        removeAndInsertBtn.id = "removeAndInsertCommentsBtn";
        removeAndInsertBtn.className = "btn btn-primary btn-sm lpad";
        removeAndInsertBtn.style.display = "none";
        removeAndInsertBtn.setAttribute("data-tooltip", "Remove comments + Insert JSDocs");
        removeAndInsertBtn.textContent = "Remove comments + Insert JSDocs";
        insertCommentsBtn.parentNode.insertBefore(removeAndInsertBtn, insertCommentsBtn.nextSibling);
      }

      document.getElementById("insertCommentsBtn")?.addEventListener("click", function () {
        handleCommentInsertion(false);
      });

      document.getElementById("removeAndInsertCommentsBtn")?.addEventListener("click", function () {
        handleCommentInsertion(true);
      });

      async function handleCommentInsertion(removeCommentsOption) {
        const originalCode = originalEditor?.getValue();
        const jsonInfo = finalVersionEditor?.getValue();

        if (originalCode && jsonInfo) {
          try {
            showLoading(true);
            const commentedCode = await insertCommentsInChunks(originalCode, jsonInfo, removeCommentsOption);
            if (finalVersionEditor) finalVersionEditor.setValue(commentedCode);
            showNotification(
              removeCommentsOption
                ? "Comments removed and new comments inserted successfully!"
                : "Comments inserted successfully!",
              "success"
            );
          } catch (error) {
            showNotification("Error inserting comments. Please check the JSON format.", "error");
          } finally {
            showLoading(false);
          }
        } else {
          showNotification("Please ensure both original code and JSON information are present.", "error");
        }
      }

      async function insertCommentsInChunks(code, jsonInfo, removeCommentsOption) {
        const chunkSize = 1000;
        const codeLines = code.split('\n');
        let processedCode = '';
        const sections = JSON.parse(jsonInfo);

        let commentCounter = 1;

        for (let i = 0; i < codeLines.length; i += chunkSize) {
          const chunkLines = codeLines.slice(i, i + chunkSize);
          const chunkCode = chunkLines.join('\n');
          const chunkSections = sections.filter(section => section.lineStart >= i + 1 && section.lineStart < i + chunkSize + 1);
          
          const processedChunk = insertCommentsIntoCode(chunkCode, JSON.stringify(chunkSections), removeCommentsOption, commentCounter);
          processedCode += processedChunk + '\n';
          commentCounter += chunkSections.length;
          const progress = Math.min(100, ((i + chunkSize) / codeLines.length) * 100);
          updateProgressBar(progress);
          await new Promise(resolve => setTimeout(resolve, 0));
        }
        return processedCode.trim();
      }
		
      document.getElementById("mergeBtn")?.addEventListener("click", async function () {
        const originalCode = originalEditor?.getValue();
        const updatedCode = updatedEditor?.getValue();
        const language = languageSelect?.value;

        if (originalCode && updatedCode) {
          try {
            showLoading(true);
            const mergedCode = await mergeCodeWithOpenAI(originalCode, updatedCode);
            if (finalVersionEditor) finalVersionEditor.setValue(mergedCode);
            showNotification("Code merged successfully!", "success");
          } catch (error) {
            showNotification("Error merging code. Please try again.", "error");
          } finally {
            showLoading(false);
          }
        } else {
          showNotification("There is currently no code to process!", "error");
        }
      });
    });
  });
</script>
</body>
</html>
